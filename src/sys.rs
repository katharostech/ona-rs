/* automatically generated by rust-bindgen 0.63.0 */

pub const DEBUG: u32 = 0;
pub const PRINT_INPUT_INITIAL: u32 = 1;
pub const PRINT_DERIVATIONS_INITIAL: u32 = 0;
pub const PRINT_CONTROL_INFO: u32 = 0;
pub const PRINT_SURPRISE: u32 = 0;
pub const PRINT_EVENTS_PRIORITY_THRESHOLD_INITIAL: f64 = 0.0;
pub const MY_RAND_MAX: u32 = 32767;
pub const ANTICIPATION_THRESHOLD_INITIAL: f64 = 0.501;
pub const ANTICIPATION_CONFIDENCE_INITIAL: f64 = 0.01;
pub const ANTICIPATE_FOR_NOT_EXISTING_SPECIFIC_TEMPORAL_IMPLICATION: u32 = 1;
pub const CONDITION_THRESHOLD_INITIAL: f64 = 0.501;
pub const DECISION_THRESHOLD_INITIAL: f64 = 0.501;
pub const MOTOR_BABBLING_CHANCE_INITIAL: f64 = 0.2;
pub const MOTOR_BABBLING_SUPPRESSION_THRESHOLD: f64 = 0.55;
pub const NOP_SUBGOALING: u32 = 1;
pub const SUBSUMPTION_CONFIDENCE_THRESHOLD: f64 = 0.05;
pub const SUBSUMPTION_FREQUENCY_THRESHOLD: f64 = 0.5;
pub const BELIEF_EVENT_SELECTIONS: u32 = 1;
pub const GOAL_EVENT_SELECTIONS: u32 = 1;
pub const EVENT_DURABILITY: f64 = 0.9999;
pub const CONCEPT_DURABILITY: f64 = 0.9;
pub const MIN_CONFIDENCE: f64 = 0.01;
pub const MIN_PRIORITY: u32 = 0;
pub const EVENT_BELIEF_DISTANCE: u32 = 20;
pub const CORRELATE_OUTCOME_RECENCY: u32 = 5;
pub const BELIEF_CONCEPT_MATCH_TARGET: u32 = 80;
pub const CONCEPT_THRESHOLD_ADAPTATION: f64 = 0.000001;
pub const ETERNAL_INPUT_USAGE_BOOST: u32 = 1000000;
pub const UNIFICATION_DEPTH: u32 = 31;
pub const MAX_SEQUENCE_LEN: u32 = 2;
pub const MAX_COMPOUND_OP_LEN: u32 = 2;
pub const MAX_SEQUENCE_TIMEDIFF: u32 = 20;
pub const ALLOW_NOT_SELECTED_PRECONDITIONS_CONDITIONING: u32 = 0;
pub const CONCEPTS_MAX: u32 = 16384;
pub const CONCEPTS_HASHTABLE_BUCKETS: u32 = 16384;
pub const CYCLING_BELIEF_EVENTS_MAX: u32 = 40;
pub const CYCLING_GOAL_EVENTS_MAX: u32 = 400;
pub const OPERATIONS_MAX: u32 = 10;
pub const OPERATIONS_BABBLE_ARGS_MAX: u32 = 10;
pub const STAMP_SIZE: u32 = 10;
pub const TABLE_SIZE: u32 = 20;
pub const COMPOUND_TERM_SIZE_MAX: u32 = 64;
pub const ATOMS_MAX: u32 = 65536;
pub const ATOMS_HASHTABLE_BUCKETS: u32 = 65536;
pub const ATOMIC_TERM_LEN_MAX: u32 = 32;
pub const NARSESE_LEN_MAX: u32 = 256;
pub const CYCLING_GOAL_EVENTS_LAYERS: u32 = 30;
pub const VAR_INTRO_HASHTABLE_BUCKETS: u32 = 64;
pub const NAR_DEFAULT_FREQUENCY: f64 = 1.0;
pub const NAR_DEFAULT_CONFIDENCE: f64 = 0.9;
pub const RELIANCE: f64 = 0.9;
pub const TRUTH_EVIDENTAL_HORIZON_INITIAL: f64 = 1.0;
pub const TRUTH_PROJECTION_DECAY_INITIAL: f64 = 0.8;
pub const MAX_CONFIDENCE: f64 = 0.99;
pub const SEMANTIC_INFERENCE_NAL_LEVEL: u32 = 6;
pub const ATOM_APPEARS_TWICE_FILTER: u32 = 1;
pub const NESTED_HOL_STATEMENT_FILTER: u32 = 1;
pub const INH_OR_SIM_HAS_DEP_VAR_FILTER: u32 = 1;
pub const HOL_STATEMENT_COMPONENT_HAS_INVALID_INH_OR_SIM_FILTER: u32 = 1;
pub const HOL_COMPONENT_NO_VAR_IS_INVALID_FILTER: u32 = 1;
pub const HOL_COMPONENT_NO_ATOMIC_IS_INVALID_FILTER: u32 = 1;
pub const JUNCTION_NOT_RIGHT_NESTED_FILTER: u32 = 1;
pub const VARS_IN_MULTI_ELEMENT_SETS_FILTER: u32 = 1;
pub const TERMS_WITH_VARS_AND_ATOMS_FILTER: u32 = 1;
pub const OCCURRENCE_ETERNAL: i32 = -1;
pub const STAMP_FREE: u32 = 0;
pub const EVENT_TYPE_GOAL: u32 = 1;
pub const EVENT_TYPE_BELIEF: u32 = 2;
pub const EVENT_TYPE_DELETED: u32 = 0;
pub const Narsese_RuleTableVars: &[u8; 11usize] = b"ABCMRSPXYZ\0";
pub const Naresese_CanonicalCopulas: &[u8; 23usize] = b"@*&|;:=$'\"/\\.-%#~+!?^_\0";
pub const PRODUCT: u8 = 42u8;
pub const EXT_INTERSECTION: u8 = 38u8;
pub const INT_INTERSECTION: u8 = 124u8;
pub const CONJUNCTION: u8 = 59u8;
pub const INHERITANCE: u8 = 58u8;
pub const SIMILARITY: u8 = 61u8;
pub const TEMPORAL_IMPLICATION: u8 = 36u8;
pub const INT_SET: u8 = 39u8;
pub const EXT_SET: u8 = 34u8;
pub const EXT_IMAGE1: u8 = 47u8;
pub const INT_IMAGE1: u8 = 92u8;
pub const SET_ELEMT: u8 = 46u8;
pub const EXT_DIFFERENCE: u8 = 45u8;
pub const EXT_IMAGE2: u8 = 37u8;
pub const INT_IMAGE2: u8 = 35u8;
pub const INT_DIFFERENCE: u8 = 126u8;
pub const SEQUENCE: u8 = 43u8;
pub const NEGATION: u8 = 33u8;
pub const IMPLICATION: u8 = 63u8;
pub const EQUIVALENCE: u8 = 94u8;
pub const DISJUNCTION: u8 = 95u8;
pub const SET_TERMINATOR: u8 = 64u8;
pub const GRAPHITE_IP_ADDRESS: &[u8; 9usize] = b"127.00.1\0";
pub const GRAPHITE_STATSD_PORT: u32 = 8125;
pub const GRAPHITE_MAX_MSG_LEN: u32 = 130;
extern "C" {
    pub fn Globals_assert(b: bool, message: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn Globals_Hash(
        data: *mut ::std::os::raw::c_long,
        pieces: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myrand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysrand(seed: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Truth {
    pub frequency: f64,
    pub confidence: f64,
}
#[test]
fn bindgen_test_layout_Truth() {
    const UNINIT: ::std::mem::MaybeUninit<Truth> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Truth>(),
        16usize,
        concat!("Size of: ", stringify!(Truth))
    );
    assert_eq!(
        ::std::mem::align_of::<Truth>(),
        8usize,
        concat!("Alignment of ", stringify!(Truth))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Truth),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).confidence) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Truth),
            "::",
            stringify!(confidence)
        )
    );
}
extern "C" {
    pub static mut TRUTH_EVIDENTAL_HORIZON: f64;
}
extern "C" {
    pub static mut TRUTH_PROJECTION_DECAY: f64;
}
extern "C" {
    pub fn Truth_w2c(w: f64) -> f64;
}
extern "C" {
    pub fn Truth_c2w(c: f64) -> f64;
}
extern "C" {
    pub fn Truth_Expectation(v: Truth) -> f64;
}
extern "C" {
    pub fn Truth_Revision(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_Deduction(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_Induction(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_Intersection(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_Eternalize(v: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_Projection(
        v: Truth,
        originalTime: ::std::os::raw::c_long,
        targetTime: ::std::os::raw::c_long,
    ) -> Truth;
}
extern "C" {
    pub fn Truth_Print(truth: *mut Truth);
}
extern "C" {
    pub fn Truth_Print2(truth: *mut Truth);
}
extern "C" {
    pub fn Truth_Abduction(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_Exemplification(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_Comparison(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_Analogy(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_Resemblance(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_StructuralDeduction(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_StructuralDeductionNegated(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_Union(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_Difference(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_Conversion(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_Negation(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_DecomposePNN(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_DecomposeNPP(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_DecomposePNP(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_DecomposePPP(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_DecomposeNNN(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_AnonymousAnalogy(v1: Truth, v2: Truth) -> Truth;
}
extern "C" {
    pub fn Truth_Equal(v1: *mut Truth, v2: *mut Truth) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Term {
    pub hashed: bool,
    pub hash: ::std::os::raw::c_long,
    pub atoms: [::std::os::raw::c_ushort; 64usize],
}
#[test]
fn bindgen_test_layout_Term() {
    const UNINIT: ::std::mem::MaybeUninit<Term> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Term>(),
        144usize,
        concat!("Size of: ", stringify!(Term))
    );
    assert_eq!(
        ::std::mem::align_of::<Term>(),
        8usize,
        concat!("Alignment of ", stringify!(Term))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Term),
            "::",
            stringify!(hashed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Term),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atoms) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Term),
            "::",
            stringify!(atoms)
        )
    );
}
extern "C" {
    pub fn Term_Equal(a: *mut Term, b: *mut Term) -> bool;
}
extern "C" {
    pub fn Term_OverrideSubterm(
        term: *mut Term,
        i: ::std::os::raw::c_int,
        subterm: *mut Term,
    ) -> bool;
}
extern "C" {
    pub fn Term_ExtractSubterm(term: *mut Term, j: ::std::os::raw::c_int) -> Term;
}
extern "C" {
    pub fn Term_Complexity(term: *mut Term) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Term_Hash(term: *mut Term) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn Term_HasAtom(term: *mut Term, atom: ::std::os::raw::c_ushort) -> bool;
}
extern "C" {
    pub fn Term_FlattenSequence(
        termArray: *mut Term,
        index: *mut ::std::os::raw::c_int,
        term: *mut Term,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Stamp {
    pub evidentalBase: [::std::os::raw::c_long; 10usize],
}
#[test]
fn bindgen_test_layout_Stamp() {
    const UNINIT: ::std::mem::MaybeUninit<Stamp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Stamp>(),
        80usize,
        concat!("Size of: ", stringify!(Stamp))
    );
    assert_eq!(
        ::std::mem::align_of::<Stamp>(),
        8usize,
        concat!("Alignment of ", stringify!(Stamp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evidentalBase) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Stamp),
            "::",
            stringify!(evidentalBase)
        )
    );
}
extern "C" {
    pub fn Stamp_make(stamp1: *mut Stamp, stamp2: *mut Stamp) -> Stamp;
}
extern "C" {
    pub fn Stamp_checkOverlap(a: *mut Stamp, b: *mut Stamp) -> bool;
}
extern "C" {
    pub fn Stamp_Equal(a: *mut Stamp, b: *mut Stamp) -> bool;
}
extern "C" {
    pub fn Stamp_print(stamp: *mut Stamp);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Event {
    pub term: Term,
    pub type_: ::std::os::raw::c_char,
    pub truth: Truth,
    pub stamp: Stamp,
    pub occurrenceTime: ::std::os::raw::c_long,
    pub occurrenceTimeOffset: f64,
    pub processed: bool,
    pub creationTime: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_Event() {
    const UNINIT: ::std::mem::MaybeUninit<Event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Event>(),
        280usize,
        concat!("Size of: ", stringify!(Event))
    );
    assert_eq!(
        ::std::mem::align_of::<Event>(),
        8usize,
        concat!("Alignment of ", stringify!(Event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Event),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truth) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(Event),
            "::",
            stringify!(truth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stamp) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(Event),
            "::",
            stringify!(stamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).occurrenceTime) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(Event),
            "::",
            stringify!(occurrenceTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).occurrenceTimeOffset) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(Event),
            "::",
            stringify!(occurrenceTimeOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processed) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(Event),
            "::",
            stringify!(processed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).creationTime) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(Event),
            "::",
            stringify!(creationTime)
        )
    );
}
extern "C" {
    pub fn Event_INIT();
}
extern "C" {
    pub fn Event_InputEvent(
        term: Term,
        type_: ::std::os::raw::c_char,
        truth: Truth,
        occurrenceTimeOffset: f64,
        currentTime: ::std::os::raw::c_long,
    ) -> Event;
}
extern "C" {
    pub fn Event_Equal(event: *mut Event, existing: *mut Event) -> bool;
}
extern "C" {
    pub fn Event_EqualTermEqualStampLessConfidentThan(
        event: *mut Event,
        existing: *mut Event,
    ) -> bool;
}
extern "C" {
    pub fn Event_Eternalized(event: *mut Event) -> Event;
}
extern "C" {
    pub static mut Narsese_atomNames: [[::std::os::raw::c_char; 32usize]; 65536usize];
}
extern "C" {
    pub static mut Narsese_operatorNames: [[::std::os::raw::c_char; 32usize]; 10usize];
}
extern "C" {
    pub static mut SELF: ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn Narsese_INIT();
}
extern "C" {
    pub fn Narsese_Expand(narsese: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Narsese_PrefixTransform(
        narsese_expanded: *mut ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Narsese_Term(narsese: *mut ::std::os::raw::c_char) -> Term;
}
extern "C" {
    pub fn Narsese_Sentence(
        narsese: *mut ::std::os::raw::c_char,
        destTerm: *mut Term,
        punctuation: *mut ::std::os::raw::c_char,
        tense: *mut ::std::os::raw::c_int,
        destTv: *mut Truth,
        occurrenceTimeOffset: *mut f64,
    );
}
extern "C" {
    pub fn Narsese_Sequence(a: *mut Term, b: *mut Term, success: *mut bool) -> Term;
}
extern "C" {
    pub fn Narsese_AtomicTerm(name: *mut ::std::os::raw::c_char) -> Term;
}
extern "C" {
    pub fn Narsese_AtomicTermIndex(name: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Narsese_CopulaIndex(name: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Narsese_PrintAtom(atom: ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn Narsese_PrintTerm(term: *mut Term);
}
extern "C" {
    pub fn Narsese_copulaEquals(
        atom: ::std::os::raw::c_ushort,
        name: ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Narsese_isOperator(atom: ::std::os::raw::c_ushort) -> bool;
}
extern "C" {
    pub fn Narsese_getOperationAtom(term: *mut Term) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn Narsese_getOperationTerm(term: *mut Term) -> Term;
}
extern "C" {
    pub fn Narsese_isOperation(term: *mut Term) -> bool;
}
extern "C" {
    pub fn Narsese_isExecutableOperation(term: *mut Term) -> bool;
}
extern "C" {
    pub fn Narsese_GetPreconditionWithoutOp(precondition: *mut Term) -> Term;
}
extern "C" {
    pub fn Narsese_IsSimpleAtom(atom: ::std::os::raw::c_ushort) -> bool;
}
extern "C" {
    pub fn Narsese_HasSimpleAtom(term: *mut Term) -> bool;
}
extern "C" {
    pub fn Narsese_StringEqual(
        name1: *mut ::std::os::raw::c_char,
        name2: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Narsese_StringHash(name: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn Term_HasOperation(term: *mut Term) -> bool;
}
extern "C" {
    pub fn Narsese_OperationSequenceAppendLeftNested(start: *mut Term, sequence: *mut Term)
        -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Implication {
    pub term: Term,
    pub truth: Truth,
    pub stamp: Stamp,
    pub occurrenceTimeOffset: f64,
    pub sourceConcept: *mut ::std::os::raw::c_void,
    pub sourceConceptId: ::std::os::raw::c_long,
    pub creationTime: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_Implication() {
    const UNINIT: ::std::mem::MaybeUninit<Implication> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Implication>(),
        272usize,
        concat!("Size of: ", stringify!(Implication))
    );
    assert_eq!(
        ::std::mem::align_of::<Implication>(),
        8usize,
        concat!("Alignment of ", stringify!(Implication))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Implication),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truth) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Implication),
            "::",
            stringify!(truth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stamp) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Implication),
            "::",
            stringify!(stamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).occurrenceTimeOffset) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(Implication),
            "::",
            stringify!(occurrenceTimeOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sourceConcept) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(Implication),
            "::",
            stringify!(sourceConcept)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sourceConceptId) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(Implication),
            "::",
            stringify!(sourceConceptId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).creationTime) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(Implication),
            "::",
            stringify!(creationTime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Substitution {
    pub map: [Term; 28usize],
    pub success: bool,
}
#[test]
fn bindgen_test_layout_Substitution() {
    const UNINIT: ::std::mem::MaybeUninit<Substitution> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Substitution>(),
        4040usize,
        concat!("Size of: ", stringify!(Substitution))
    );
    assert_eq!(
        ::std::mem::align_of::<Substitution>(),
        8usize,
        concat!("Alignment of ", stringify!(Substitution))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Substitution),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).success) as usize - ptr as usize },
        4032usize,
        concat!(
            "Offset of field: ",
            stringify!(Substitution),
            "::",
            stringify!(success)
        )
    );
}
extern "C" {
    pub fn Variable_isIndependentVariable(atom: ::std::os::raw::c_ushort) -> bool;
}
extern "C" {
    pub fn Variable_isDependentVariable(atom: ::std::os::raw::c_ushort) -> bool;
}
extern "C" {
    pub fn Variable_isQueryVariable(atom: ::std::os::raw::c_ushort) -> bool;
}
extern "C" {
    pub fn Variable_isVariable(atom: ::std::os::raw::c_ushort) -> bool;
}
extern "C" {
    pub fn Variable_hasVariable(
        term: *mut Term,
        independent: bool,
        dependent: bool,
        query: bool,
    ) -> bool;
}
extern "C" {
    pub fn Variable_Unify(general: *mut Term, specific: *mut Term) -> Substitution;
}
extern "C" {
    pub fn Variable_Unify2(
        general: *mut Term,
        specific: *mut Term,
        unifyQueryVarOnly: bool,
    ) -> Substitution;
}
extern "C" {
    pub fn Variable_ApplySubstitute(
        term: Term,
        substitution: Substitution,
        success: *mut bool,
    ) -> Term;
}
extern "C" {
    pub fn Variable_IntroduceImplicationVariables(
        implication: Term,
        success: *mut bool,
        extensionally: bool,
    ) -> Term;
}
extern "C" {
    pub fn Variable_IntroduceConjunctionVariables(
        conjunction: Term,
        success: *mut bool,
        extensionally: bool,
    ) -> Term;
}
extern "C" {
    pub fn Variable_Normalize(term: *mut Term);
}
extern "C" {
    pub fn Inference_EventUpdate(ev: *mut Event, currentTime: ::std::os::raw::c_long) -> Event;
}
extern "C" {
    pub fn Inference_BeliefIntersection(a: *mut Event, b: *mut Event, success: *mut bool) -> Event;
}
extern "C" {
    pub fn Inference_BeliefInduction(
        a: *mut Event,
        b: *mut Event,
        success: *mut bool,
    ) -> Implication;
}
extern "C" {
    pub fn Inference_ImplicationRevision(a: *mut Implication, b: *mut Implication) -> Implication;
}
extern "C" {
    pub fn Inference_GoalDeduction(
        component: *mut Event,
        compound: *mut Implication,
        currentTime: ::std::os::raw::c_long,
    ) -> Event;
}
extern "C" {
    pub fn Inference_GoalSequenceDeduction(
        compound: *mut Event,
        component: *mut Event,
        currentTime: ::std::os::raw::c_long,
    ) -> Event;
}
extern "C" {
    pub fn Inference_RevisionAndChoice(
        existing_potential: *mut Event,
        incoming_spike: *mut Event,
        currentTime: ::std::os::raw::c_long,
        revised: *mut bool,
    ) -> Event;
}
extern "C" {
    pub fn Inference_BeliefDeduction(component: *mut Event, compound: *mut Implication) -> Event;
}
extern "C" {
    pub fn Inference_BeliefInductionDeclarative(
        a: *mut Event,
        b: *mut Implication,
        success: *mut bool,
    ) -> Implication;
}
extern "C" {
    pub fn Inference_BeliefDeductionDeclarative(
        component: *mut Event,
        compound: *mut Implication,
    ) -> Event;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Table {
    pub array: [Implication; 20usize],
    pub itemsAmount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Table() {
    const UNINIT: ::std::mem::MaybeUninit<Table> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Table>(),
        5448usize,
        concat!("Size of: ", stringify!(Table))
    );
    assert_eq!(
        ::std::mem::align_of::<Table>(),
        8usize,
        concat!("Alignment of ", stringify!(Table))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Table),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itemsAmount) as usize - ptr as usize },
        5440usize,
        concat!(
            "Offset of field: ",
            stringify!(Table),
            "::",
            stringify!(itemsAmount)
        )
    );
}
extern "C" {
    pub fn Table_Add(table: *mut Table, imp: *mut Implication) -> *mut Implication;
}
extern "C" {
    pub fn Table_Remove(table: *mut Table, index: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Table_AddAndRevise(table: *mut Table, imp: *mut Implication) -> *mut Implication;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Usage {
    pub useCount: ::std::os::raw::c_long,
    pub lastUsed: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_Usage() {
    const UNINIT: ::std::mem::MaybeUninit<Usage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Usage>(),
        16usize,
        concat!("Size of: ", stringify!(Usage))
    );
    assert_eq!(
        ::std::mem::align_of::<Usage>(),
        8usize,
        concat!("Alignment of ", stringify!(Usage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Usage),
            "::",
            stringify!(useCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastUsed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Usage),
            "::",
            stringify!(lastUsed)
        )
    );
}
extern "C" {
    pub fn Usage_usefulness(usage: Usage, currentTime: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn Usage_use(
        usage: Usage,
        currentTime: ::std::os::raw::c_long,
        eternalInput: bool,
    ) -> Usage;
}
extern "C" {
    pub fn Usage_Print(usage: *mut Usage);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Concept {
    pub id: ::std::os::raw::c_long,
    pub usage: Usage,
    pub term: Term,
    pub belief: Event,
    pub belief_spike: Event,
    pub predicted_belief: Event,
    pub goal_spike: Event,
    pub precondition_beliefs: [Table; 11usize],
    pub priority: f64,
    pub processID: ::std::os::raw::c_long,
    pub processID2: ::std::os::raw::c_long,
    pub processID3: ::std::os::raw::c_long,
    pub lastSelectionTime: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_Concept() {
    const UNINIT: ::std::mem::MaybeUninit<Concept> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Concept>(),
        61256usize,
        concat!("Size of: ", stringify!(Concept))
    );
    assert_eq!(
        ::std::mem::align_of::<Concept>(),
        8usize,
        concat!("Alignment of ", stringify!(Concept))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Concept),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Concept),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Concept),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).belief) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(Concept),
            "::",
            stringify!(belief)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).belief_spike) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(Concept),
            "::",
            stringify!(belief_spike)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).predicted_belief) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(Concept),
            "::",
            stringify!(predicted_belief)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).goal_spike) as usize - ptr as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(Concept),
            "::",
            stringify!(goal_spike)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).precondition_beliefs) as usize - ptr as usize },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(Concept),
            "::",
            stringify!(precondition_beliefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        61216usize,
        concat!(
            "Offset of field: ",
            stringify!(Concept),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processID) as usize - ptr as usize },
        61224usize,
        concat!(
            "Offset of field: ",
            stringify!(Concept),
            "::",
            stringify!(processID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processID2) as usize - ptr as usize },
        61232usize,
        concat!(
            "Offset of field: ",
            stringify!(Concept),
            "::",
            stringify!(processID2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processID3) as usize - ptr as usize },
        61240usize,
        concat!(
            "Offset of field: ",
            stringify!(Concept),
            "::",
            stringify!(processID3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastSelectionTime) as usize - ptr as usize },
        61248usize,
        concat!(
            "Offset of field: ",
            stringify!(Concept),
            "::",
            stringify!(lastSelectionTime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Stack {
    pub items: *mut *mut ::std::os::raw::c_void,
    pub stackpointer: ::std::os::raw::c_int,
    pub maxElements: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Stack() {
    const UNINIT: ::std::mem::MaybeUninit<Stack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Stack>(),
        16usize,
        concat!("Size of: ", stringify!(Stack))
    );
    assert_eq!(
        ::std::mem::align_of::<Stack>(),
        8usize,
        concat!("Alignment of ", stringify!(Stack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).items) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Stack),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stackpointer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Stack),
            "::",
            stringify!(stackpointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxElements) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Stack),
            "::",
            stringify!(maxElements)
        )
    );
}
extern "C" {
    pub fn Stack_INIT(
        stack: *mut Stack,
        items: *mut *mut ::std::os::raw::c_void,
        maxElements: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Stack_Push(stack: *mut Stack, item: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn Stack_Pop(stack: *mut Stack) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Stack_IsEmpty(stack: *mut Stack) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConceptChainElement {
    pub c: *mut Concept,
    pub next: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ConceptChainElement() {
    const UNINIT: ::std::mem::MaybeUninit<ConceptChainElement> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ConceptChainElement>(),
        16usize,
        concat!("Size of: ", stringify!(ConceptChainElement))
    );
    assert_eq!(
        ::std::mem::align_of::<ConceptChainElement>(),
        8usize,
        concat!("Alignment of ", stringify!(ConceptChainElement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConceptChainElement),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ConceptChainElement),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub static mut conceptChainElementStoragePointers: [*mut ConceptChainElement; 507904usize];
}
extern "C" {
    pub static mut conceptChainElementStorage: [ConceptChainElement; 507904usize];
}
extern "C" {
    pub static mut conceptChainElementStack: Stack;
}
extern "C" {
    pub static mut invertedAtomIndex: [*mut ConceptChainElement; 65536usize];
}
extern "C" {
    pub fn InvertedAtomIndex_INIT();
}
extern "C" {
    pub fn InvertedAtomIndex_AddConcept(term: Term, c: *mut Concept);
}
extern "C" {
    pub fn InvertedAtomIndex_RemoveConcept(term: Term, c: *mut Concept);
}
extern "C" {
    pub fn InvertedAtomIndex_Print();
}
extern "C" {
    pub fn InvertedAtomIndex_GetConceptChain(
        atom: ::std::os::raw::c_ushort,
    ) -> *mut ConceptChainElement;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Item {
    pub priority: f64,
    pub address: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_Item() {
    const UNINIT: ::std::mem::MaybeUninit<Item> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Item>(),
        16usize,
        concat!("Size of: ", stringify!(Item))
    );
    assert_eq!(
        ::std::mem::align_of::<Item>(),
        8usize,
        concat!("Alignment of ", stringify!(Item))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Item),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Item),
            "::",
            stringify!(address)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PriorityQueue {
    pub items: *mut Item,
    pub itemsAmount: ::std::os::raw::c_int,
    pub maxElements: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PriorityQueue() {
    const UNINIT: ::std::mem::MaybeUninit<PriorityQueue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PriorityQueue>(),
        16usize,
        concat!("Size of: ", stringify!(PriorityQueue))
    );
    assert_eq!(
        ::std::mem::align_of::<PriorityQueue>(),
        8usize,
        concat!("Alignment of ", stringify!(PriorityQueue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).items) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PriorityQueue),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itemsAmount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PriorityQueue),
            "::",
            stringify!(itemsAmount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxElements) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PriorityQueue),
            "::",
            stringify!(maxElements)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PriorityQueue_Push_Feedback {
    pub added: bool,
    pub addedItem: Item,
    pub evicted: bool,
    pub evictedItem: Item,
}
#[test]
fn bindgen_test_layout_PriorityQueue_Push_Feedback() {
    const UNINIT: ::std::mem::MaybeUninit<PriorityQueue_Push_Feedback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PriorityQueue_Push_Feedback>(),
        48usize,
        concat!("Size of: ", stringify!(PriorityQueue_Push_Feedback))
    );
    assert_eq!(
        ::std::mem::align_of::<PriorityQueue_Push_Feedback>(),
        8usize,
        concat!("Alignment of ", stringify!(PriorityQueue_Push_Feedback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).added) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PriorityQueue_Push_Feedback),
            "::",
            stringify!(added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addedItem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PriorityQueue_Push_Feedback),
            "::",
            stringify!(addedItem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evicted) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PriorityQueue_Push_Feedback),
            "::",
            stringify!(evicted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evictedItem) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PriorityQueue_Push_Feedback),
            "::",
            stringify!(evictedItem)
        )
    );
}
extern "C" {
    pub fn PriorityQueue_INIT(
        queue: *mut PriorityQueue,
        items: *mut Item,
        maxElements: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn PriorityQueue_Push(
        queue: *mut PriorityQueue,
        priority: f64,
    ) -> PriorityQueue_Push_Feedback;
}
extern "C" {
    pub fn PriorityQueue_PopAt(
        queue: *mut PriorityQueue,
        i: ::std::os::raw::c_int,
        returnItemAddress: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn PriorityQueue_Rebuild(queue: *mut PriorityQueue);
}
extern "C" {
    pub fn PriorityQueue_PopMin(
        queue: *mut PriorityQueue,
        returnItemAddress: *mut *mut ::std::os::raw::c_void,
        returnItemPriority: *mut f64,
    ) -> bool;
}
extern "C" {
    pub fn PriorityQueue_PopMax(
        queue: *mut PriorityQueue,
        returnItemAddress: *mut *mut ::std::os::raw::c_void,
        returnItemPriority: *mut f64,
    ) -> bool;
}
pub type Equal = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type Hash = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VMItem {
    pub key: *mut ::std::os::raw::c_void,
    pub value: *mut ::std::os::raw::c_void,
    pub next: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VMItem() {
    const UNINIT: ::std::mem::MaybeUninit<VMItem> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VMItem>(),
        24usize,
        concat!("Size of: ", stringify!(VMItem))
    );
    assert_eq!(
        ::std::mem::align_of::<VMItem>(),
        8usize,
        concat!("Alignment of ", stringify!(VMItem))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VMItem),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VMItem),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VMItem),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashTable {
    pub storageptrs: *mut *mut VMItem,
    pub storage: *mut VMItem,
    pub HT: *mut *mut VMItem,
    pub VMStack: Stack,
    pub buckets: ::std::os::raw::c_int,
    pub equal: Equal,
    pub hash: Hash,
}
#[test]
fn bindgen_test_layout_HashTable() {
    const UNINIT: ::std::mem::MaybeUninit<HashTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HashTable>(),
        64usize,
        concat!("Size of: ", stringify!(HashTable))
    );
    assert_eq!(
        ::std::mem::align_of::<HashTable>(),
        8usize,
        concat!("Alignment of ", stringify!(HashTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).storageptrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HashTable),
            "::",
            stringify!(storageptrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).storage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HashTable),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HT) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HashTable),
            "::",
            stringify!(HT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VMStack) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HashTable),
            "::",
            stringify!(VMStack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buckets) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HashTable),
            "::",
            stringify!(buckets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HashTable),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HashTable),
            "::",
            stringify!(hash)
        )
    );
}
extern "C" {
    pub fn HashTable_Get(
        hashtable: *mut HashTable,
        key: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn HashTable_Set(
        hashtable: *mut HashTable,
        key: *mut ::std::os::raw::c_void,
        value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn HashTable_Delete(hashtable: *mut HashTable, key: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn HashTable_INIT(
        hashtable: *mut HashTable,
        storage: *mut VMItem,
        storageptrs: *mut *mut VMItem,
        HT: *mut *mut VMItem,
        buckets: ::std::os::raw::c_int,
        maxElements: ::std::os::raw::c_int,
        equal: Equal,
        hash: Hash,
    );
}
extern "C" {
    pub fn HashTable_MaximumChainLength(hashtable: *mut HashTable) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut PROPAGATION_THRESHOLD: f64;
}
extern "C" {
    pub static mut PRINT_DERIVATIONS: bool;
}
extern "C" {
    pub static mut PRINT_INPUT: bool;
}
extern "C" {
    pub static mut conceptPriorityThreshold: f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Feedback {
    pub subs: Substitution,
    pub failed: bool,
}
#[test]
fn bindgen_test_layout_Feedback() {
    const UNINIT: ::std::mem::MaybeUninit<Feedback> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Feedback>(),
        4048usize,
        concat!("Size of: ", stringify!(Feedback))
    );
    assert_eq!(
        ::std::mem::align_of::<Feedback>(),
        8usize,
        concat!("Alignment of ", stringify!(Feedback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Feedback),
            "::",
            stringify!(subs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failed) as usize - ptr as usize },
        4040usize,
        concat!(
            "Offset of field: ",
            stringify!(Feedback),
            "::",
            stringify!(failed)
        )
    );
}
pub type Action = ::std::option::Option<unsafe extern "C" fn(arg1: Term) -> Feedback>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Operation {
    pub term: Term,
    pub action: Action,
    pub arguments: [Term; 10usize],
    pub stdinOutput: bool,
}
#[test]
fn bindgen_test_layout_Operation() {
    const UNINIT: ::std::mem::MaybeUninit<Operation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Operation>(),
        1600usize,
        concat!("Size of: ", stringify!(Operation))
    );
    assert_eq!(
        ::std::mem::align_of::<Operation>(),
        8usize,
        concat!("Alignment of ", stringify!(Operation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Operation),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Operation),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arguments) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(Operation),
            "::",
            stringify!(arguments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stdinOutput) as usize - ptr as usize },
        1592usize,
        concat!(
            "Offset of field: ",
            stringify!(Operation),
            "::",
            stringify!(stdinOutput)
        )
    );
}
extern "C" {
    pub static mut ontology_handling: bool;
}
extern "C" {
    pub static mut selectedBeliefs: [Event; 1usize];
}
extern "C" {
    pub static mut selectedBeliefsPriority: [f64; 1usize];
}
extern "C" {
    pub static mut beliefsSelectedCnt: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut selectedGoals: [Event; 1usize];
}
extern "C" {
    pub static mut selectedGoalsPriority: [f64; 1usize];
}
extern "C" {
    pub static mut goalsSelectedCnt: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut concept_id: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut concepts: PriorityQueue;
}
extern "C" {
    pub static mut cycling_belief_events: PriorityQueue;
}
extern "C" {
    pub static mut cycling_goal_events: [PriorityQueue; 30usize];
}
extern "C" {
    pub static mut HTconcepts: HashTable;
}
extern "C" {
    pub static mut operations: [Operation; 10usize];
}
extern "C" {
    pub static mut PRINT_EVENTS_PRIORITY_THRESHOLD: f64;
}
extern "C" {
    pub fn Memory_INIT();
}
extern "C" {
    pub fn Memory_FindConceptByTerm(term: *mut Term) -> *mut Concept;
}
extern "C" {
    pub fn Memory_Conceptualize(
        term: *mut Term,
        currentTime: ::std::os::raw::c_long,
    ) -> *mut Concept;
}
extern "C" {
    pub fn Memory_AddEvent(
        event: *mut Event,
        currentTime: ::std::os::raw::c_long,
        priority: f64,
        input: bool,
        derived: bool,
        revised: bool,
        layer: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Memory_AddInputEvent(event: *mut Event, currentTime: ::std::os::raw::c_long);
}
extern "C" {
    pub fn Memory_AddOperation(id: ::std::os::raw::c_int, op: Operation);
}
extern "C" {
    pub fn Memory_ImplicationValid(imp: *mut Implication) -> bool;
}
extern "C" {
    pub fn Memory_printAddedEvent(
        event: *mut Event,
        priority: f64,
        input: bool,
        derived: bool,
        revised: bool,
        controlInfo: bool,
    );
}
extern "C" {
    pub fn Memory_printAddedImplication(
        implication: *mut Term,
        truth: *mut Truth,
        occurrenceTimeOffset: f64,
        priority: f64,
        input: bool,
        revised: bool,
        controlInfo: bool,
    );
}
extern "C" {
    pub fn Memory_getOperationID(term: *mut Term) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut CONDITION_THRESHOLD: f64;
}
extern "C" {
    pub static mut DECISION_THRESHOLD: f64;
}
extern "C" {
    pub static mut ANTICIPATION_THRESHOLD: f64;
}
extern "C" {
    pub static mut ANTICIPATION_CONFIDENCE: f64;
}
extern "C" {
    pub static mut MOTOR_BABBLING_CHANCE: f64;
}
extern "C" {
    pub static mut BABBLING_OPS: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Decision {
    pub desire: f64,
    pub execute: bool,
    pub operationID: [::std::os::raw::c_int; 2usize],
    pub op: [Operation; 2usize],
    pub arguments: [Term; 2usize],
    pub missing_specific_implication: Implication,
    pub reason: *mut Event,
}
#[test]
fn bindgen_test_layout_Decision() {
    const UNINIT: ::std::mem::MaybeUninit<Decision> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Decision>(),
        3792usize,
        concat!("Size of: ", stringify!(Decision))
    );
    assert_eq!(
        ::std::mem::align_of::<Decision>(),
        8usize,
        concat!("Alignment of ", stringify!(Decision))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desire) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Decision),
            "::",
            stringify!(desire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).execute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Decision),
            "::",
            stringify!(execute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operationID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Decision),
            "::",
            stringify!(operationID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Decision),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arguments) as usize - ptr as usize },
        3224usize,
        concat!(
            "Offset of field: ",
            stringify!(Decision),
            "::",
            stringify!(arguments)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).missing_specific_implication) as usize - ptr as usize
        },
        3512usize,
        concat!(
            "Offset of field: ",
            stringify!(Decision),
            "::",
            stringify!(missing_specific_implication)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        3784usize,
        concat!(
            "Offset of field: ",
            stringify!(Decision),
            "::",
            stringify!(reason)
        )
    );
}
extern "C" {
    pub fn Decision_INIT();
}
extern "C" {
    pub fn Decision_Execute(decision: *mut Decision);
}
extern "C" {
    pub fn Decision_Anticipate(
        operationID: ::std::os::raw::c_int,
        op_term: Term,
        currentTime: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn Decision_Suggest(
        goalconcept: *mut Concept,
        goal: *mut Event,
        currentTime: ::std::os::raw::c_long,
    ) -> Decision;
}
extern "C" {
    pub fn Decision_BetterDecision(best_decision: Decision, decision: Decision) -> Decision;
}
extern "C" {
    pub fn NAL_GenerateRuleTable();
}
extern "C" {
    pub fn NAL_DerivedEvent(
        conclusionTerm: Term,
        conclusionOccurrence: ::std::os::raw::c_long,
        conclusionTruth: Truth,
        stamp: Stamp,
        currentTime: ::std::os::raw::c_long,
        parentPriority: f64,
        conceptPriority: f64,
        occurrenceTimeOffset: f64,
        validation_concept: *mut Concept,
        validation_cid: ::std::os::raw::c_long,
        varIntro: bool,
    );
}
extern "C" {
    pub fn NAL_DerivedEvent2(
        conclusionTerm: Term,
        conclusionOccurrence: ::std::os::raw::c_long,
        conclusionTruth: Truth,
        stamp: Stamp,
        currentTime: ::std::os::raw::c_long,
        parentPriority: f64,
        conceptPriority: f64,
        occurrenceTimeOffset: f64,
        validation_concept: *mut Concept,
        validation_cid: ::std::os::raw::c_long,
        varIntro: bool,
        allowOnlyExtVarIntroAndTwoIndependentVars: bool,
    );
}
extern "C" {
    pub fn RuleTable_Apply(
        term1: Term,
        term2: Term,
        truth1: Truth,
        truth2: Truth,
        conclusionOccurrence: ::std::os::raw::c_long,
        occurrenceTimeOffset: f64,
        conclusionStamp: Stamp,
        currentTime: ::std::os::raw::c_long,
        parentPriority: f64,
        conceptPriority: f64,
        doublePremise: bool,
        validation_concept: *mut Concept,
        validation_cid: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn RuleTable_Reduce(term1: Term) -> Term;
}
extern "C" {
    pub static mut Stats_countConceptsMatchedTotal: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut Stats_countConceptsMatchedMax: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut HTatoms: HashTable;
}
extern "C" {
    pub fn Stats_Print(currentTime: ::std::os::raw::c_long);
}
extern "C" {
    pub fn UDP_INIT_Receiver(
        ip: *mut ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn UDP_INIT_Sender() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn UDP_ReceiveData(
        sockfd: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buffersize: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn UDP_SendData(
        sockfd: ::std::os::raw::c_int,
        ip: *mut ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buffersize: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Metric_send(path: *const ::std::os::raw::c_char, value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Cycle_Perform(currentTime: ::std::os::raw::c_long);
}
extern "C" {
    pub fn Cycle_INIT();
}
extern "C" {
    pub static mut currentTime: ::std::os::raw::c_long;
}
extern "C" {
    pub fn NAR_INIT();
}
extern "C" {
    pub fn NAR_Cycles(cycles: ::std::os::raw::c_int);
}
extern "C" {
    pub fn NAR_AddInput(
        term: Term,
        type_: ::std::os::raw::c_char,
        truth: Truth,
        eternal: bool,
        occurrenceTimeOffset: f64,
    ) -> Event;
}
extern "C" {
    pub fn NAR_AddInputBelief(term: Term) -> Event;
}
extern "C" {
    pub fn NAR_AddInputGoal(term: Term) -> Event;
}
extern "C" {
    pub fn NAR_AddOperation(atomname: *mut ::std::os::raw::c_char, procedure: Action);
}
extern "C" {
    pub fn NAR_AddInputNarsese(narsese_sentence: *mut ::std::os::raw::c_char);
}
